//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.4.1.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* eslint-disable */
// ReSharper disable InconsistentNaming

export class Client {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "https://localhost:32771/";
    }

    /**
     * @return OK
     */
    register(body: RegisterRequest): Promise<void> {
        let url_ = this.baseUrl + "/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            credentials: 'include',
            mode: 'cors',
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRegister(_response);
        });
    }

    protected processRegister(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param useCookies (optional) 
     * @param useSessionCookies (optional) 
     * @return OK
     */
    login(useCookies: boolean | undefined, useSessionCookies: boolean | undefined, body: LoginRequest): Promise<AccessTokenResponse> {
        let url_ = this.baseUrl + "/login?";
        if (useCookies === null)
            throw new globalThis.Error("The parameter 'useCookies' cannot be null.");
        else if (useCookies !== undefined)
            url_ += "useCookies=" + encodeURIComponent("" + useCookies) + "&";
        if (useSessionCookies === null)
            throw new globalThis.Error("The parameter 'useSessionCookies' cannot be null.");
        else if (useSessionCookies !== undefined)
            url_ += "useSessionCookies=" + encodeURIComponent("" + useSessionCookies) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            credentials: 'include',
            mode: 'cors',
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogin(_response);
        });
    }

    protected processLogin(response: Response): Promise<AccessTokenResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AccessTokenResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AccessTokenResponse>(null as any);
    }

    /**
     * @return OK
     */
    refresh(body: RefreshRequest): Promise<AccessTokenResponse> {
        let url_ = this.baseUrl + "/refresh";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            credentials: 'include',
            mode: 'cors',
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRefresh(_response);
        });
    }

    protected processRefresh(response: Response): Promise<AccessTokenResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AccessTokenResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AccessTokenResponse>(null as any);
    }

    /**
     * @param changedEmail (optional) 
     * @return OK
     */
    mapBetterIdentityApi_confirmEmail(userId: string, code: string, changedEmail: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/confirmEmail?";
        if (userId === undefined || userId === null)
            throw new globalThis.Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (code === undefined || code === null)
            throw new globalThis.Error("The parameter 'code' must be defined and cannot be null.");
        else
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        if (changedEmail === null)
            throw new globalThis.Error("The parameter 'changedEmail' cannot be null.");
        else if (changedEmail !== undefined)
            url_ += "changedEmail=" + encodeURIComponent("" + changedEmail) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            credentials: 'include',
            mode: 'cors',
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMapBetterIdentityApi_confirmEmail(_response);
        });
    }

    protected processMapBetterIdentityApi_confirmEmail(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    resendConfirmationEmail(body: ResendConfirmationEmailRequest): Promise<void> {
        let url_ = this.baseUrl + "/resendConfirmationEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            credentials: 'include',
            mode: 'cors',
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processResendConfirmationEmail(_response);
        });
    }

    protected processResendConfirmationEmail(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    forgotPassword(body: ForgotPasswordRequest): Promise<void> {
        let url_ = this.baseUrl + "/forgotPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            credentials: 'include',
            mode: 'cors',
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processForgotPassword(_response);
        });
    }

    protected processForgotPassword(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    resetPassword(body: ResetPasswordRequest): Promise<void> {
        let url_ = this.baseUrl + "/resetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            credentials: 'include',
            mode: 'cors',
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processResetPassword(_response);
        });
    }

    protected processResetPassword(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    _2fa(body: TwoFactorRequest): Promise<TwoFactorResponse> {
        let url_ = this.baseUrl + "/manage/2fa";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            credentials: 'include',
            mode: 'cors',
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.process2fa(_response);
        });
    }

    protected process2fa(response: Response): Promise<TwoFactorResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TwoFactorResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Not Found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TwoFactorResponse>(null as any);
    }

    /**
     * @return OK
     */
    infoGET(): Promise<InfoResponse> {
        let url_ = this.baseUrl + "/manage/info";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            credentials: 'include',
            mode: 'cors',
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInfoGET(_response);
        });
    }

    protected processInfoGET(response: Response): Promise<InfoResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InfoResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Not Found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InfoResponse>(null as any);
    }

    /**
     * @return OK
     */
    infoPOST(body: InfoRequest): Promise<InfoResponse> {
        let url_ = this.baseUrl + "/manage/info";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            credentials: 'include',
            mode: 'cors',
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInfoPOST(_response);
        });
    }

    protected processInfoPOST(response: Response): Promise<InfoResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InfoResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Not Found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InfoResponse>(null as any);
    }

    /**
     * @param returnUrl (optional) 
     * @return OK
     */
    performExternalLogin(returnUrl: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Account/PerformExternalLogin";
        url_ = url_.replace(/[?&]$/, "");

        let content_ = "";
        if (returnUrl === null)
            throw new globalThis.Error("The parameter 'returnUrl' cannot be null.");
        else if (returnUrl !== undefined)
            content_ += encodeURIComponent("returnUrl") + "=" + encodeURIComponent("" + returnUrl) + "&";
        content_ = content_.replace(/&$/, "");

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            credentials: 'include',
            mode: 'cors',
            headers: {
                "Content-Type": "multipart/form-data",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPerformExternalLogin(_response);
        });
    }

    protected processPerformExternalLogin(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    logout(): Promise<void> {
        let url_ = this.baseUrl + "/Account/Logout";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            credentials: 'include',
            mode: 'cors',
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogout(_response);
        });
    }

    protected processLogout(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param provider (optional) 
     * @return OK
     */
    linkExternalLogin(provider: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Account/Manage/LinkExternalLogin";
        url_ = url_.replace(/[?&]$/, "");

        let content_ = "";
        if (provider === null)
            throw new globalThis.Error("The parameter 'provider' cannot be null.");
        else if (provider !== undefined)
            content_ += encodeURIComponent("provider") + "=" + encodeURIComponent("" + provider) + "&";
        content_ = content_.replace(/&$/, "");

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            credentials: 'include',
            mode: 'cors',
            headers: {
                "Content-Type": "multipart/form-data",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLinkExternalLogin(_response);
        });
    }

    protected processLinkExternalLogin(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    downloadPersonalData(): Promise<void> {
        let url_ = this.baseUrl + "/Account/Manage/DownloadPersonalData";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            credentials: 'include',
            mode: 'cors',
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDownloadPersonalData(_response);
        });
    }

    protected processDownloadPersonalData(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    getWeatherForecast(): Promise<WeatherForecast[]> {
        let url_ = this.baseUrl + "/WeatherForecast";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            credentials: 'include',
            mode: 'cors',
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetWeatherForecast(_response);
        });
    }

    protected processGetWeatherForecast(response: Response): Promise<WeatherForecast[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WeatherForecast.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WeatherForecast[]>(null as any);
    }

    /**
     * @param weekNumber (optional) 
     * @param year (optional) 
     * @param sport (optional) 
     * @param returnOnlyGamesThatHaveStarted (optional) 
     * @return OK
     */
    queryGames(weekNumber: number | undefined, year: string | undefined, sport: number | undefined, returnOnlyGamesThatHaveStarted: boolean | undefined): Promise<GameDTO[]> {
        let url_ = this.baseUrl + "/api/games/QueryGamesAsync?";
        if (weekNumber === null)
            throw new globalThis.Error("The parameter 'weekNumber' cannot be null.");
        else if (weekNumber !== undefined)
            url_ += "weekNumber=" + encodeURIComponent("" + weekNumber) + "&";
        if (year === null)
            throw new globalThis.Error("The parameter 'year' cannot be null.");
        else if (year !== undefined)
            url_ += "year=" + encodeURIComponent("" + year) + "&";
        if (sport === null)
            throw new globalThis.Error("The parameter 'sport' cannot be null.");
        else if (sport !== undefined)
            url_ += "sport=" + encodeURIComponent("" + sport) + "&";
        if (returnOnlyGamesThatHaveStarted === null)
            throw new globalThis.Error("The parameter 'returnOnlyGamesThatHaveStarted' cannot be null.");
        else if (returnOnlyGamesThatHaveStarted !== undefined)
            url_ += "returnOnlyGamesThatHaveStarted=" + encodeURIComponent("" + returnOnlyGamesThatHaveStarted) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            credentials: 'include',
            mode: 'cors',
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processQueryGames(_response);
        });
    }

    protected processQueryGames(response: Response): Promise<GameDTO[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GameDTO.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GameDTO[]>(null as any);
    }

    /**
     * @param username (optional) 
     * @return OK
     */
    updateUsername(username: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/identity/UpdateUsername?";
        if (username === null)
            throw new globalThis.Error("The parameter 'username' cannot be null.");
        else if (username !== undefined)
            url_ += "username=" + encodeURIComponent("" + username) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            credentials: 'include',
            mode: 'cors',
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateUsername(_response);
        });
    }

    protected processUpdateUsername(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param showArchivedLeagues (optional) 
     * @return OK
     */
    getLeaguesForCurrentUser(showArchivedLeagues: boolean | undefined): Promise<League[]> {
        let url_ = this.baseUrl + "/api/leagues/GetLeaguesForCurrentUser?";
        if (showArchivedLeagues === null)
            throw new globalThis.Error("The parameter 'showArchivedLeagues' cannot be null.");
        else if (showArchivedLeagues !== undefined)
            url_ += "showArchivedLeagues=" + encodeURIComponent("" + showArchivedLeagues) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            credentials: 'include',
            mode: 'cors',
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetLeaguesForCurrentUser(_response);
        });
    }

    protected processGetLeaguesForCurrentUser(response: Response): Promise<League[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(League.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<League[]>(null as any);
    }

    /**
     * @param leagueId (optional) 
     * @return OK
     */
    getLeagueById(leagueId: string | undefined): Promise<LeagueDTO> {
        let url_ = this.baseUrl + "/api/leagues/GetLeagueById?";
        if (leagueId === null)
            throw new globalThis.Error("The parameter 'leagueId' cannot be null.");
        else if (leagueId !== undefined)
            url_ += "leagueId=" + encodeURIComponent("" + leagueId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            credentials: 'include',
            mode: 'cors',
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetLeagueById(_response);
        });
    }

    protected processGetLeagueById(response: Response): Promise<LeagueDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LeagueDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LeagueDTO>(null as any);
    }

    /**
     * @param leagueId (optional) 
     * @return OK
     */
    renewLeague(leagueId: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/leagues/RenewLeague?";
        if (leagueId === null)
            throw new globalThis.Error("The parameter 'leagueId' cannot be null.");
        else if (leagueId !== undefined)
            url_ += "leagueId=" + encodeURIComponent("" + leagueId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            credentials: 'include',
            mode: 'cors',
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRenewLeague(_response);
        });
    }

    protected processRenewLeague(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param leagueId (optional) 
     * @return OK
     */
    leaveLeague(leagueId: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/leagues/LeaveLeague?";
        if (leagueId === null)
            throw new globalThis.Error("The parameter 'leagueId' cannot be null.");
        else if (leagueId !== undefined)
            url_ += "leagueId=" + encodeURIComponent("" + leagueId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            credentials: 'include',
            mode: 'cors',
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLeaveLeague(_response);
        });
    }

    protected processLeaveLeague(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param leagueId (optional) 
     * @param userId (optional) 
     * @return OK
     */
    kickUser(leagueId: string | undefined, userId: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/leagues/KickUser?";
        if (leagueId === null)
            throw new globalThis.Error("The parameter 'leagueId' cannot be null.");
        else if (leagueId !== undefined)
            url_ += "leagueId=" + encodeURIComponent("" + leagueId) + "&";
        if (userId === null)
            throw new globalThis.Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            credentials: 'include',
            mode: 'cors',
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processKickUser(_response);
        });
    }

    protected processKickUser(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param leagueId (optional) 
     * @param userId (optional) 
     * @return OK
     */
    makeUserAsAdmin(leagueId: string | undefined, userId: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/leagues/MakeUserAsAdmin?";
        if (leagueId === null)
            throw new globalThis.Error("The parameter 'leagueId' cannot be null.");
        else if (leagueId !== undefined)
            url_ += "leagueId=" + encodeURIComponent("" + leagueId) + "&";
        if (userId === null)
            throw new globalThis.Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            credentials: 'include',
            mode: 'cors',
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMakeUserAsAdmin(_response);
        });
    }

    protected processMakeUserAsAdmin(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param leagueId (optional) 
     * @param userId (optional) 
     * @return OK
     */
    removeUserAsAdmin(leagueId: string | undefined, userId: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/leagues/RemoveUserAsAdmin?";
        if (leagueId === null)
            throw new globalThis.Error("The parameter 'leagueId' cannot be null.");
        else if (leagueId !== undefined)
            url_ += "leagueId=" + encodeURIComponent("" + leagueId) + "&";
        if (userId === null)
            throw new globalThis.Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            credentials: 'include',
            mode: 'cors',
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRemoveUserAsAdmin(_response);
        });
    }

    protected processRemoveUserAsAdmin(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param leagueId (optional) 
     * @param showAllGames (optional) 
     * @param showIconsForPicks (optional) 
     * @return OK
     */
    updateLeagueUserSettings(leagueId: string | undefined, showAllGames: boolean | undefined, showIconsForPicks: boolean | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/leagues/UpdateLeagueUserSettings?";
        if (leagueId === null)
            throw new globalThis.Error("The parameter 'leagueId' cannot be null.");
        else if (leagueId !== undefined)
            url_ += "leagueId=" + encodeURIComponent("" + leagueId) + "&";
        if (showAllGames === null)
            throw new globalThis.Error("The parameter 'showAllGames' cannot be null.");
        else if (showAllGames !== undefined)
            url_ += "showAllGames=" + encodeURIComponent("" + showAllGames) + "&";
        if (showIconsForPicks === null)
            throw new globalThis.Error("The parameter 'showIconsForPicks' cannot be null.");
        else if (showIconsForPicks !== undefined)
            url_ += "showIconsForPicks=" + encodeURIComponent("" + showIconsForPicks) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            credentials: 'include',
            mode: 'cors',
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateLeagueUserSettings(_response);
        });
    }

    protected processUpdateLeagueUserSettings(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param leagueId (optional) 
     * @param userId (optional) 
     * @param showAllGames (optional) 
     * @param showIconsForPicks (optional) 
     * @return OK
     */
    updateLeagueStandingsSettings(leagueId: string | undefined, userId: string | undefined, showAllGames: boolean | undefined, showIconsForPicks: boolean | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/leagues/UpdateLeagueStandingsSettings?";
        if (leagueId === null)
            throw new globalThis.Error("The parameter 'leagueId' cannot be null.");
        else if (leagueId !== undefined)
            url_ += "leagueId=" + encodeURIComponent("" + leagueId) + "&";
        if (userId === null)
            throw new globalThis.Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (showAllGames === null)
            throw new globalThis.Error("The parameter 'showAllGames' cannot be null.");
        else if (showAllGames !== undefined)
            url_ += "showAllGames=" + encodeURIComponent("" + showAllGames) + "&";
        if (showIconsForPicks === null)
            throw new globalThis.Error("The parameter 'showIconsForPicks' cannot be null.");
        else if (showIconsForPicks !== undefined)
            url_ += "showIconsForPicks=" + encodeURIComponent("" + showIconsForPicks) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            credentials: 'include',
            mode: 'cors',
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateLeagueStandingsSettings(_response);
        });
    }

    protected processUpdateLeagueStandingsSettings(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param leagueId (optional) 
     * @return OK
     */
    getUserMappingForLeague(leagueId: string | undefined): Promise<{ [key: string]: UserInfo; }> {
        let url_ = this.baseUrl + "/api/leagues/GetUserMappingForLeague?";
        if (leagueId === null)
            throw new globalThis.Error("The parameter 'leagueId' cannot be null.");
        else if (leagueId !== undefined)
            url_ += "leagueId=" + encodeURIComponent("" + leagueId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            credentials: 'include',
            mode: 'cors',
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUserMappingForLeague(_response);
        });
    }

    protected processGetUserMappingForLeague(response: Response): Promise<{ [key: string]: UserInfo; }> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (result200 as any)![key] = resultData200[key] ? UserInfo.fromJS(resultData200[key]) : new UserInfo();
                }
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<{ [key: string]: UserInfo; }>(null as any);
    }

    /**
     * @return OK
     */
    updateLeague(body: LeagueDTO): Promise<void> {
        let url_ = this.baseUrl + "/api/leagues/UpdateLeague";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            credentials: 'include',
            mode: 'cors',
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateLeague(_response);
        });
    }

    protected processUpdateLeague(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    updateLeagueSettings(body: UpdateLeagueSettingsRequest): Promise<void> {
        let url_ = this.baseUrl + "/api/leagues/UpdateLeagueSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            credentials: 'include',
            mode: 'cors',
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateLeagueSettings(_response);
        });
    }

    protected processUpdateLeagueSettings(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    addLeague(body: LeagueDTO): Promise<void> {
        let url_ = this.baseUrl + "/api/leagues/AddLeague";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            credentials: 'include',
            mode: 'cors',
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddLeague(_response);
        });
    }

    protected processAddLeague(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param leagueId (optional) 
     * @return OK
     */
    archiveLeague(leagueId: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/leagues/ArchiveLeague?";
        if (leagueId === null)
            throw new globalThis.Error("The parameter 'leagueId' cannot be null.");
        else if (leagueId !== undefined)
            url_ += "leagueId=" + encodeURIComponent("" + leagueId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            credentials: 'include',
            mode: 'cors',
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processArchiveLeague(_response);
        });
    }

    protected processArchiveLeague(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param sport (optional) 
     * @return OK
     */
    getPublicLeagues(sport: number | undefined): Promise<LeagueDTO[]> {
        let url_ = this.baseUrl + "/api/leagues/GetPublicLeagues?";
        if (sport === null)
            throw new globalThis.Error("The parameter 'sport' cannot be null.");
        else if (sport !== undefined)
            url_ += "sport=" + encodeURIComponent("" + sport) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            credentials: 'include',
            mode: 'cors',
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPublicLeagues(_response);
        });
    }

    protected processGetPublicLeagues(response: Response): Promise<LeagueDTO[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LeagueDTO.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LeagueDTO[]>(null as any);
    }

    /**
     * @param leagueId (optional) 
     * @param weekNumber (optional) 
     * @param leagueType (optional) 
     * @return OK
     */
    getWeekPickForUser(leagueId: string | undefined, weekNumber: number | undefined, leagueType: number | undefined): Promise<IWeekPick> {
        let url_ = this.baseUrl + "/api/picks/GetWeekPickForUser?";
        if (leagueId === null)
            throw new globalThis.Error("The parameter 'leagueId' cannot be null.");
        else if (leagueId !== undefined)
            url_ += "leagueId=" + encodeURIComponent("" + leagueId) + "&";
        if (weekNumber === null)
            throw new globalThis.Error("The parameter 'weekNumber' cannot be null.");
        else if (weekNumber !== undefined)
            url_ += "weekNumber=" + encodeURIComponent("" + weekNumber) + "&";
        if (leagueType === null)
            throw new globalThis.Error("The parameter 'leagueType' cannot be null.");
        else if (leagueType !== undefined)
            url_ += "leagueType=" + encodeURIComponent("" + leagueType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            credentials: 'include',
            mode: 'cors',
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetWeekPickForUser(_response);
        });
    }

    protected processGetWeekPickForUser(response: Response): Promise<IWeekPick> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IWeekPick.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IWeekPick>(null as any);
    }

    /**
     * @param leagueId (optional) 
     * @param weekNumber (optional) 
     * @return OK
     */
    getAllSpreadWeekPicks(leagueId: string | undefined, weekNumber: number | undefined): Promise<SpreadWeekPickDTO[]> {
        let url_ = this.baseUrl + "/api/picks/GetAllSpreadWeekPicksAsync?";
        if (leagueId === null)
            throw new globalThis.Error("The parameter 'leagueId' cannot be null.");
        else if (leagueId !== undefined)
            url_ += "leagueId=" + encodeURIComponent("" + leagueId) + "&";
        if (weekNumber === null)
            throw new globalThis.Error("The parameter 'weekNumber' cannot be null.");
        else if (weekNumber !== undefined)
            url_ += "weekNumber=" + encodeURIComponent("" + weekNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            credentials: 'include',
            mode: 'cors',
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllSpreadWeekPicks(_response);
        });
    }

    protected processGetAllSpreadWeekPicks(response: Response): Promise<SpreadWeekPickDTO[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SpreadWeekPickDTO.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SpreadWeekPickDTO[]>(null as any);
    }

    /**
     * @param leagueId (optional) 
     * @param weekNumber (optional) 
     * @return OK
     */
    getSpreadWeekPicksForUser(leagueId: string | undefined, weekNumber: number | undefined): Promise<SpreadWeekPickDTO> {
        let url_ = this.baseUrl + "/api/picks/GetSpreadWeekPicksForUserAsync?";
        if (leagueId === null)
            throw new globalThis.Error("The parameter 'leagueId' cannot be null.");
        else if (leagueId !== undefined)
            url_ += "leagueId=" + encodeURIComponent("" + leagueId) + "&";
        if (weekNumber === null)
            throw new globalThis.Error("The parameter 'weekNumber' cannot be null.");
        else if (weekNumber !== undefined)
            url_ += "weekNumber=" + encodeURIComponent("" + weekNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            credentials: 'include',
            mode: 'cors',
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSpreadWeekPicksForUser(_response);
        });
    }

    protected processGetSpreadWeekPicksForUser(response: Response): Promise<SpreadWeekPickDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SpreadWeekPickDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SpreadWeekPickDTO>(null as any);
    }

    /**
     * @return OK
     */
    upsertSpreadWeekPick(body: SpreadWeekPickDTO): Promise<void> {
        let url_ = this.baseUrl + "/api/picks/UpsertSpreadWeekPickAsync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            credentials: 'include',
            mode: 'cors',
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpsertSpreadWeekPick(_response);
        });
    }

    protected processUpsertSpreadWeekPick(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    isAuthorized(): Promise<string> {
        let url_ = this.baseUrl + "/api/user/IsAuthorized";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            credentials: 'include',
            mode: 'cors',
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processIsAuthorized(_response);
        });
    }

    protected processIsAuthorized(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @return OK
     */
    getUserSettingFromUserId(): Promise<UserSettings> {
        let url_ = this.baseUrl + "/api/user/GetUserSettingFromUserIdAsync";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            credentials: 'include',
            mode: 'cors',
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUserSettingFromUserId(_response);
        });
    }

    protected processGetUserSettingFromUserId(response: Response): Promise<UserSettings> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserSettings.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSettings>(null as any);
    }

    /**
     * @return OK
     */
    getUserInfo(): Promise<UserInfo> {
        let url_ = this.baseUrl + "/api/user/GetUserInfo";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            credentials: 'include',
            mode: 'cors',
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUserInfo(_response);
        });
    }

    protected processGetUserInfo(response: Response): Promise<UserInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserInfo.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserInfo>(null as any);
    }

    /**
     * @return OK
     */
    updateUserSettings(body: UserSettings): Promise<void> {
        let url_ = this.baseUrl + "/api/user/UpdateUserSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            credentials: 'include',
            mode: 'cors',
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateUserSettings(_response);
        });
    }

    protected processUpdateUserSettings(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param leagueId (optional) 
     * @param weekNumber (optional) 
     * @return OK
     */
    getSpreadWeekResult(leagueId: string | undefined, weekNumber: number | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/weekresults/GetSpreadWeekResultAsync?";
        if (leagueId === null)
            throw new globalThis.Error("The parameter 'leagueId' cannot be null.");
        else if (leagueId !== undefined)
            url_ += "leagueId=" + encodeURIComponent("" + leagueId) + "&";
        if (weekNumber === null)
            throw new globalThis.Error("The parameter 'weekNumber' cannot be null.");
        else if (weekNumber !== undefined)
            url_ += "weekNumber=" + encodeURIComponent("" + weekNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            credentials: 'include',
            mode: 'cors',
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSpreadWeekResult(_response);
        });
    }

    protected processGetSpreadWeekResult(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class AccessTokenResponse implements IAccessTokenResponse {
    tokenType?: string | undefined;
    accessToken!: string;
    expiresIn!: number;
    refreshToken!: string;

    [key: string]: any;

    constructor(data?: IAccessTokenResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.tokenType = _data["tokenType"];
            this.accessToken = _data["accessToken"];
            this.expiresIn = _data["expiresIn"];
            this.refreshToken = _data["refreshToken"];
        }
    }

    static fromJS(data: any): AccessTokenResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AccessTokenResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["tokenType"] = this.tokenType;
        data["accessToken"] = this.accessToken;
        data["expiresIn"] = this.expiresIn;
        data["refreshToken"] = this.refreshToken;
        return data;
    }
}

export interface IAccessTokenResponse {
    tokenType?: string | undefined;
    accessToken: string;
    expiresIn: number;
    refreshToken: string;

    [key: string]: any;
}

export class ForgotPasswordRequest implements IForgotPasswordRequest {
    email!: string;

    [key: string]: any;

    constructor(data?: IForgotPasswordRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): ForgotPasswordRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ForgotPasswordRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["email"] = this.email;
        return data;
    }
}

export interface IForgotPasswordRequest {
    email: string;

    [key: string]: any;
}

export class GameDTO implements IGameDTO {
    id?: string;
    partitionKey?: string | undefined;
    isDeleted?: boolean;
    sportsAPIGameID?: string | undefined;
    sport?: number;
    awayTeam?: TeamDTO;
    homeTeam?: TeamDTO;
    currentSpread?: Spread | undefined;
    spreadAtLockTime?: Spread | undefined;
    currentMoneyline?: Moneyline | undefined;
    moneylineAtLockTime?: Moneyline | undefined;
    currentTotalPointsSpread?: TotalPointsSpread | undefined;
    totalPointsAtLockTime?: TotalPointsSpread | undefined;
    spreadHistory?: Spread2[];
    moneylineHistory?: Moneyline2[];
    totalSpreadHistory?: TotalPointsSpread2[];
    gameStartTime?: Date;
    weekNumber?: number;
    year?: string | undefined;
    isLocked?: boolean;
    result?: GameResult | undefined;
    summary?: GameSummaryObject | undefined;

    [key: string]: any;

    constructor(data?: IGameDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.partitionKey = _data["partitionKey"];
            this.isDeleted = _data["isDeleted"];
            this.sportsAPIGameID = _data["sportsAPIGameID"];
            this.sport = _data["sport"];
            this.awayTeam = _data["awayTeam"] ? TeamDTO.fromJS(_data["awayTeam"]) : undefined as any;
            this.homeTeam = _data["homeTeam"] ? TeamDTO.fromJS(_data["homeTeam"]) : undefined as any;
            this.currentSpread = _data["currentSpread"] ? Spread.fromJS(_data["currentSpread"]) : undefined as any;
            this.spreadAtLockTime = _data["spreadAtLockTime"] ? Spread.fromJS(_data["spreadAtLockTime"]) : undefined as any;
            this.currentMoneyline = _data["currentMoneyline"] ? Moneyline.fromJS(_data["currentMoneyline"]) : undefined as any;
            this.moneylineAtLockTime = _data["moneylineAtLockTime"] ? Moneyline.fromJS(_data["moneylineAtLockTime"]) : undefined as any;
            this.currentTotalPointsSpread = _data["currentTotalPointsSpread"] ? TotalPointsSpread.fromJS(_data["currentTotalPointsSpread"]) : undefined as any;
            this.totalPointsAtLockTime = _data["totalPointsAtLockTime"] ? TotalPointsSpread.fromJS(_data["totalPointsAtLockTime"]) : undefined as any;
            if (Array.isArray(_data["spreadHistory"])) {
                this.spreadHistory = [] as any;
                for (let item of _data["spreadHistory"])
                    this.spreadHistory!.push(Spread2.fromJS(item));
            }
            if (Array.isArray(_data["moneylineHistory"])) {
                this.moneylineHistory = [] as any;
                for (let item of _data["moneylineHistory"])
                    this.moneylineHistory!.push(Moneyline2.fromJS(item));
            }
            if (Array.isArray(_data["totalSpreadHistory"])) {
                this.totalSpreadHistory = [] as any;
                for (let item of _data["totalSpreadHistory"])
                    this.totalSpreadHistory!.push(TotalPointsSpread2.fromJS(item));
            }
            this.gameStartTime = _data["gameStartTime"] ? new Date(_data["gameStartTime"].toString()) : undefined as any;
            this.weekNumber = _data["weekNumber"];
            this.year = _data["year"];
            this.isLocked = _data["isLocked"];
            this.result = _data["result"] ? GameResult.fromJS(_data["result"]) : undefined as any;
            this.summary = _data["summary"] ? GameSummaryObject.fromJS(_data["summary"]) : undefined as any;
        }
    }

    static fromJS(data: any): GameDTO {
        data = typeof data === 'object' ? data : {};
        let result = new GameDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["partitionKey"] = this.partitionKey;
        data["isDeleted"] = this.isDeleted;
        data["sportsAPIGameID"] = this.sportsAPIGameID;
        data["sport"] = this.sport;
        data["awayTeam"] = this.awayTeam ? this.awayTeam.toJSON() : undefined as any;
        data["homeTeam"] = this.homeTeam ? this.homeTeam.toJSON() : undefined as any;
        data["currentSpread"] = this.currentSpread ? this.currentSpread.toJSON() : undefined as any;
        data["spreadAtLockTime"] = this.spreadAtLockTime ? this.spreadAtLockTime.toJSON() : undefined as any;
        data["currentMoneyline"] = this.currentMoneyline ? this.currentMoneyline.toJSON() : undefined as any;
        data["moneylineAtLockTime"] = this.moneylineAtLockTime ? this.moneylineAtLockTime.toJSON() : undefined as any;
        data["currentTotalPointsSpread"] = this.currentTotalPointsSpread ? this.currentTotalPointsSpread.toJSON() : undefined as any;
        data["totalPointsAtLockTime"] = this.totalPointsAtLockTime ? this.totalPointsAtLockTime.toJSON() : undefined as any;
        if (Array.isArray(this.spreadHistory)) {
            data["spreadHistory"] = [];
            for (let item of this.spreadHistory)
                data["spreadHistory"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.moneylineHistory)) {
            data["moneylineHistory"] = [];
            for (let item of this.moneylineHistory)
                data["moneylineHistory"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.totalSpreadHistory)) {
            data["totalSpreadHistory"] = [];
            for (let item of this.totalSpreadHistory)
                data["totalSpreadHistory"].push(item ? item.toJSON() : undefined as any);
        }
        data["gameStartTime"] = this.gameStartTime ? this.gameStartTime.toISOString() : undefined as any;
        data["weekNumber"] = this.weekNumber;
        data["year"] = this.year;
        data["isLocked"] = this.isLocked;
        data["result"] = this.result ? this.result.toJSON() : undefined as any;
        data["summary"] = this.summary ? this.summary.toJSON() : undefined as any;
        return data;
    }
}

export interface IGameDTO {
    id?: string;
    partitionKey?: string | undefined;
    isDeleted?: boolean;
    sportsAPIGameID?: string | undefined;
    sport?: number;
    awayTeam?: TeamDTO;
    homeTeam?: TeamDTO;
    currentSpread?: Spread | undefined;
    spreadAtLockTime?: Spread | undefined;
    currentMoneyline?: Moneyline | undefined;
    moneylineAtLockTime?: Moneyline | undefined;
    currentTotalPointsSpread?: TotalPointsSpread | undefined;
    totalPointsAtLockTime?: TotalPointsSpread | undefined;
    spreadHistory?: Spread2[];
    moneylineHistory?: Moneyline2[];
    totalSpreadHistory?: TotalPointsSpread2[];
    gameStartTime?: Date;
    weekNumber?: number;
    year?: string | undefined;
    isLocked?: boolean;
    result?: GameResult | undefined;
    summary?: GameSummaryObject | undefined;

    [key: string]: any;
}

export class GameResult implements IGameResult {
    gameID!: string;
    awayTeamName?: string;
    homeTeamName?: string;
    awayScore?: number;
    homeScore?: number;
    status?: number;
    awayScoreByPeriod?: number[];
    homeScoreByPeriod?: number[];
    periodTimeRemaining?: string;
    currentPeriod?: number;
    scoreSnapshots?: GameScoreSnapshot[];

    [key: string]: any;

    constructor(data?: IGameResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.gameID = _data["gameID"];
            this.awayTeamName = _data["awayTeamName"];
            this.homeTeamName = _data["homeTeamName"];
            this.awayScore = _data["awayScore"];
            this.homeScore = _data["homeScore"];
            this.status = _data["status"];
            if (Array.isArray(_data["awayScoreByPeriod"])) {
                this.awayScoreByPeriod = [] as any;
                for (let item of _data["awayScoreByPeriod"])
                    this.awayScoreByPeriod!.push(item);
            }
            if (Array.isArray(_data["homeScoreByPeriod"])) {
                this.homeScoreByPeriod = [] as any;
                for (let item of _data["homeScoreByPeriod"])
                    this.homeScoreByPeriod!.push(item);
            }
            this.periodTimeRemaining = _data["periodTimeRemaining"];
            this.currentPeriod = _data["currentPeriod"];
            if (Array.isArray(_data["scoreSnapshots"])) {
                this.scoreSnapshots = [] as any;
                for (let item of _data["scoreSnapshots"])
                    this.scoreSnapshots!.push(GameScoreSnapshot.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GameResult {
        data = typeof data === 'object' ? data : {};
        let result = new GameResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["gameID"] = this.gameID;
        data["awayTeamName"] = this.awayTeamName;
        data["homeTeamName"] = this.homeTeamName;
        data["awayScore"] = this.awayScore;
        data["homeScore"] = this.homeScore;
        data["status"] = this.status;
        if (Array.isArray(this.awayScoreByPeriod)) {
            data["awayScoreByPeriod"] = [];
            for (let item of this.awayScoreByPeriod)
                data["awayScoreByPeriod"].push(item);
        }
        if (Array.isArray(this.homeScoreByPeriod)) {
            data["homeScoreByPeriod"] = [];
            for (let item of this.homeScoreByPeriod)
                data["homeScoreByPeriod"].push(item);
        }
        data["periodTimeRemaining"] = this.periodTimeRemaining;
        data["currentPeriod"] = this.currentPeriod;
        if (Array.isArray(this.scoreSnapshots)) {
            data["scoreSnapshots"] = [];
            for (let item of this.scoreSnapshots)
                data["scoreSnapshots"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IGameResult {
    gameID: string;
    awayTeamName?: string;
    homeTeamName?: string;
    awayScore?: number;
    homeScore?: number;
    status?: number;
    awayScoreByPeriod?: number[];
    homeScoreByPeriod?: number[];
    periodTimeRemaining?: string;
    currentPeriod?: number;
    scoreSnapshots?: GameScoreSnapshot[];

    [key: string]: any;
}

export class GameScoreSnapshot implements IGameScoreSnapshot {
    awayScore?: number;
    homeScore?: number;
    periodTimeRemaining?: string | undefined;
    currentPeriod?: number;
    snapshotTime?: Date;

    [key: string]: any;

    constructor(data?: IGameScoreSnapshot) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.awayScore = _data["awayScore"];
            this.homeScore = _data["homeScore"];
            this.periodTimeRemaining = _data["periodTimeRemaining"];
            this.currentPeriod = _data["currentPeriod"];
            this.snapshotTime = _data["snapshotTime"] ? new Date(_data["snapshotTime"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): GameScoreSnapshot {
        data = typeof data === 'object' ? data : {};
        let result = new GameScoreSnapshot();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["awayScore"] = this.awayScore;
        data["homeScore"] = this.homeScore;
        data["periodTimeRemaining"] = this.periodTimeRemaining;
        data["currentPeriod"] = this.currentPeriod;
        data["snapshotTime"] = this.snapshotTime ? this.snapshotTime.toISOString() : undefined as any;
        return data;
    }
}

export interface IGameScoreSnapshot {
    awayScore?: number;
    homeScore?: number;
    periodTimeRemaining?: string | undefined;
    currentPeriod?: number;
    snapshotTime?: Date;

    [key: string]: any;
}

export class GameSummaryObject implements IGameSummaryObject {
    leadChanges?: number;
    spreadResultChanges?: number;
    numberOfBackdoorCovers?: number;

    [key: string]: any;

    constructor(data?: IGameSummaryObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.leadChanges = _data["leadChanges"];
            this.spreadResultChanges = _data["spreadResultChanges"];
            this.numberOfBackdoorCovers = _data["numberOfBackdoorCovers"];
        }
    }

    static fromJS(data: any): GameSummaryObject {
        data = typeof data === 'object' ? data : {};
        let result = new GameSummaryObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["leadChanges"] = this.leadChanges;
        data["spreadResultChanges"] = this.spreadResultChanges;
        data["numberOfBackdoorCovers"] = this.numberOfBackdoorCovers;
        return data;
    }
}

export interface IGameSummaryObject {
    leadChanges?: number;
    spreadResultChanges?: number;
    numberOfBackdoorCovers?: number;

    [key: string]: any;
}

export class HttpValidationProblemDetails implements IHttpValidationProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
    errors?: { [key: string]: string[]; };

    [key: string]: any;

    constructor(data?: IHttpValidationProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
            if (_data["errors"]) {
                this.errors = {} as any;
                for (let key in _data["errors"]) {
                    if (_data["errors"].hasOwnProperty(key))
                        (this.errors as any)![key] = _data["errors"][key] !== undefined ? _data["errors"][key] : [];
                }
            }
        }
    }

    static fromJS(data: any): HttpValidationProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new HttpValidationProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        if (this.errors) {
            data["errors"] = {};
            for (let key in this.errors) {
                if (this.errors.hasOwnProperty(key))
                    (data["errors"] as any)[key] = (this.errors as any)[key];
            }
        }
        return data;
    }
}

export interface IHttpValidationProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
    errors?: { [key: string]: string[]; };

    [key: string]: any;
}

export class InfoRequest implements IInfoRequest {
    newEmail?: string | undefined;
    newPassword?: string | undefined;
    oldPassword?: string | undefined;

    [key: string]: any;

    constructor(data?: IInfoRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.newEmail = _data["newEmail"];
            this.newPassword = _data["newPassword"];
            this.oldPassword = _data["oldPassword"];
        }
    }

    static fromJS(data: any): InfoRequest {
        data = typeof data === 'object' ? data : {};
        let result = new InfoRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["newEmail"] = this.newEmail;
        data["newPassword"] = this.newPassword;
        data["oldPassword"] = this.oldPassword;
        return data;
    }
}

export interface IInfoRequest {
    newEmail?: string | undefined;
    newPassword?: string | undefined;
    oldPassword?: string | undefined;

    [key: string]: any;
}

export class InfoResponse implements IInfoResponse {
    email!: string;
    isEmailConfirmed!: boolean;

    [key: string]: any;

    constructor(data?: IInfoResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.email = _data["email"];
            this.isEmailConfirmed = _data["isEmailConfirmed"];
        }
    }

    static fromJS(data: any): InfoResponse {
        data = typeof data === 'object' ? data : {};
        let result = new InfoResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["email"] = this.email;
        data["isEmailConfirmed"] = this.isEmailConfirmed;
        return data;
    }
}

export interface IInfoResponse {
    email: string;
    isEmailConfirmed: boolean;

    [key: string]: any;
}

export class ISportsUtils implements IISportsUtils {

    [key: string]: any;

    constructor(data?: IISportsUtils) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): ISportsUtils {
        data = typeof data === 'object' ? data : {};
        let result = new ISportsUtils();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IISportsUtils {

    [key: string]: any;
}

export class IWeekPick implements IIWeekPick {
    id?: string | undefined;
    leagueId?: string | undefined;

    [key: string]: any;

    constructor(data?: IIWeekPick) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.leagueId = _data["leagueId"];
        }
    }

    static fromJS(data: any): IWeekPick {
        data = typeof data === 'object' ? data : {};
        let result = new IWeekPick();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["leagueId"] = this.leagueId;
        return data;
    }
}

export interface IIWeekPick {
    id?: string | undefined;
    leagueId?: string | undefined;

    [key: string]: any;
}

export class League implements ILeague {
    id?: string;
    partitionKey?: string;
    year?: string;
    leagueName!: string;
    leagueCreatorId!: string;
    leagueAdminIds?: string[];
    isPublic?: boolean;
    type!: number;
    sport!: number;
    settings!: LeagueSettings;
    userSeasons?: UserSeason[];
    latestProcessedWeek?: number;
    startingWeekNumber?: number;
    endingWeekNumber?: number;
    sportsUtils?: ISportsUtils;
    currentWeekNumber?: number;
    seasonInformation?: SeasonDateInformation | undefined;
    isArchived?: boolean;
    premiumStatus?: number;
    renewalRequestedTimeSent?: Date | undefined;

    [key: string]: any;

    constructor(data?: ILeague) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
        if (!data) {
            this.settings = new LeagueSettings();
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.partitionKey = _data["partitionKey"];
            this.year = _data["year"];
            this.leagueName = _data["leagueName"];
            this.leagueCreatorId = _data["leagueCreatorId"];
            if (Array.isArray(_data["leagueAdminIds"])) {
                this.leagueAdminIds = [] as any;
                for (let item of _data["leagueAdminIds"])
                    this.leagueAdminIds!.push(item);
            }
            this.isPublic = _data["isPublic"];
            this.type = _data["type"];
            this.sport = _data["sport"];
            this.settings = _data["settings"] ? LeagueSettings.fromJS(_data["settings"]) : new LeagueSettings();
            if (Array.isArray(_data["userSeasons"])) {
                this.userSeasons = [] as any;
                for (let item of _data["userSeasons"])
                    this.userSeasons!.push(UserSeason.fromJS(item));
            }
            this.latestProcessedWeek = _data["latestProcessedWeek"];
            this.startingWeekNumber = _data["startingWeekNumber"];
            this.endingWeekNumber = _data["endingWeekNumber"];
            this.sportsUtils = _data["sportsUtils"] ? ISportsUtils.fromJS(_data["sportsUtils"]) : undefined as any;
            this.currentWeekNumber = _data["currentWeekNumber"];
            this.seasonInformation = _data["seasonInformation"] ? SeasonDateInformation.fromJS(_data["seasonInformation"]) : undefined as any;
            this.isArchived = _data["isArchived"];
            this.premiumStatus = _data["premiumStatus"];
            this.renewalRequestedTimeSent = _data["renewalRequestedTimeSent"] ? new Date(_data["renewalRequestedTimeSent"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): League {
        data = typeof data === 'object' ? data : {};
        let result = new League();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["partitionKey"] = this.partitionKey;
        data["year"] = this.year;
        data["leagueName"] = this.leagueName;
        data["leagueCreatorId"] = this.leagueCreatorId;
        if (Array.isArray(this.leagueAdminIds)) {
            data["leagueAdminIds"] = [];
            for (let item of this.leagueAdminIds)
                data["leagueAdminIds"].push(item);
        }
        data["isPublic"] = this.isPublic;
        data["type"] = this.type;
        data["sport"] = this.sport;
        data["settings"] = this.settings ? this.settings.toJSON() : undefined as any;
        if (Array.isArray(this.userSeasons)) {
            data["userSeasons"] = [];
            for (let item of this.userSeasons)
                data["userSeasons"].push(item ? item.toJSON() : undefined as any);
        }
        data["latestProcessedWeek"] = this.latestProcessedWeek;
        data["startingWeekNumber"] = this.startingWeekNumber;
        data["endingWeekNumber"] = this.endingWeekNumber;
        data["sportsUtils"] = this.sportsUtils ? this.sportsUtils.toJSON() : undefined as any;
        data["currentWeekNumber"] = this.currentWeekNumber;
        data["seasonInformation"] = this.seasonInformation ? this.seasonInformation.toJSON() : undefined as any;
        data["isArchived"] = this.isArchived;
        data["premiumStatus"] = this.premiumStatus;
        data["renewalRequestedTimeSent"] = this.renewalRequestedTimeSent ? this.renewalRequestedTimeSent.toISOString() : undefined as any;
        return data;
    }
}

export interface ILeague {
    id?: string;
    partitionKey?: string;
    year?: string;
    leagueName: string;
    leagueCreatorId: string;
    leagueAdminIds?: string[];
    isPublic?: boolean;
    type: number;
    sport: number;
    settings: LeagueSettings;
    userSeasons?: UserSeason[];
    latestProcessedWeek?: number;
    startingWeekNumber?: number;
    endingWeekNumber?: number;
    sportsUtils?: ISportsUtils;
    currentWeekNumber?: number;
    seasonInformation?: SeasonDateInformation | undefined;
    isArchived?: boolean;
    premiumStatus?: number;
    renewalRequestedTimeSent?: Date | undefined;

    [key: string]: any;
}

export class LeagueDTO implements ILeagueDTO {
    id?: string;
    partitionKey?: string;
    year?: string;
    leagueName?: string;
    leagueCreatorId?: string;
    leagueAdminIds?: string[];
    isPublic?: boolean;
    type?: number;
    sport?: number;
    settings?: LeagueSettings;
    userSeasons?: UserSeasonDTO[];
    latestProcessedWeek?: number;
    currentWeekNumber?: number;
    startingWeekNumber?: number;
    endingWeekNumber?: number;
    isArchived?: boolean;
    premiumStatus?: number;
    seasonInformation?: SeasonDateInformation2;

    [key: string]: any;

    constructor(data?: ILeagueDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.partitionKey = _data["partitionKey"];
            this.year = _data["year"];
            this.leagueName = _data["leagueName"];
            this.leagueCreatorId = _data["leagueCreatorId"];
            if (Array.isArray(_data["leagueAdminIds"])) {
                this.leagueAdminIds = [] as any;
                for (let item of _data["leagueAdminIds"])
                    this.leagueAdminIds!.push(item);
            }
            this.isPublic = _data["isPublic"];
            this.type = _data["type"];
            this.sport = _data["sport"];
            this.settings = _data["settings"] ? LeagueSettings.fromJS(_data["settings"]) : undefined as any;
            if (Array.isArray(_data["userSeasons"])) {
                this.userSeasons = [] as any;
                for (let item of _data["userSeasons"])
                    this.userSeasons!.push(UserSeasonDTO.fromJS(item));
            }
            this.latestProcessedWeek = _data["latestProcessedWeek"];
            this.currentWeekNumber = _data["currentWeekNumber"];
            this.startingWeekNumber = _data["startingWeekNumber"];
            this.endingWeekNumber = _data["endingWeekNumber"];
            this.isArchived = _data["isArchived"];
            this.premiumStatus = _data["premiumStatus"];
            this.seasonInformation = _data["seasonInformation"] ? SeasonDateInformation2.fromJS(_data["seasonInformation"]) : undefined as any;
        }
    }

    static fromJS(data: any): LeagueDTO {
        data = typeof data === 'object' ? data : {};
        let result = new LeagueDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["partitionKey"] = this.partitionKey;
        data["year"] = this.year;
        data["leagueName"] = this.leagueName;
        data["leagueCreatorId"] = this.leagueCreatorId;
        if (Array.isArray(this.leagueAdminIds)) {
            data["leagueAdminIds"] = [];
            for (let item of this.leagueAdminIds)
                data["leagueAdminIds"].push(item);
        }
        data["isPublic"] = this.isPublic;
        data["type"] = this.type;
        data["sport"] = this.sport;
        data["settings"] = this.settings ? this.settings.toJSON() : undefined as any;
        if (Array.isArray(this.userSeasons)) {
            data["userSeasons"] = [];
            for (let item of this.userSeasons)
                data["userSeasons"].push(item ? item.toJSON() : undefined as any);
        }
        data["latestProcessedWeek"] = this.latestProcessedWeek;
        data["currentWeekNumber"] = this.currentWeekNumber;
        data["startingWeekNumber"] = this.startingWeekNumber;
        data["endingWeekNumber"] = this.endingWeekNumber;
        data["isArchived"] = this.isArchived;
        data["premiumStatus"] = this.premiumStatus;
        data["seasonInformation"] = this.seasonInformation ? this.seasonInformation.toJSON() : undefined as any;
        return data;
    }
}

export interface ILeagueDTO {
    id?: string;
    partitionKey?: string;
    year?: string;
    leagueName?: string;
    leagueCreatorId?: string;
    leagueAdminIds?: string[];
    isPublic?: boolean;
    type?: number;
    sport?: number;
    settings?: LeagueSettings;
    userSeasons?: UserSeasonDTO[];
    latestProcessedWeek?: number;
    currentWeekNumber?: number;
    startingWeekNumber?: number;
    endingWeekNumber?: number;
    isArchived?: boolean;
    premiumStatus?: number;
    seasonInformation?: SeasonDateInformation2;

    [key: string]: any;
}

export class LeagueSettings implements ILeagueSettings {
    totalPicks?: number;
    keyPicks?: number;
    keyPickBonus?: number;
    weekStartingMoney?: number;
    minimumGamesToPick?: number;
    allowParlays?: boolean;
    allowWinningsForBetting?: boolean;
    lockPicksAfterTheyAreMade?: boolean;
    lockSpreadsDuringWeek?: boolean;

    [key: string]: any;

    constructor(data?: ILeagueSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.totalPicks = _data["totalPicks"];
            this.keyPicks = _data["keyPicks"];
            this.keyPickBonus = _data["keyPickBonus"];
            this.weekStartingMoney = _data["weekStartingMoney"];
            this.minimumGamesToPick = _data["minimumGamesToPick"];
            this.allowParlays = _data["allowParlays"];
            this.allowWinningsForBetting = _data["allowWinningsForBetting"];
            this.lockPicksAfterTheyAreMade = _data["lockPicksAfterTheyAreMade"];
            this.lockSpreadsDuringWeek = _data["lockSpreadsDuringWeek"];
        }
    }

    static fromJS(data: any): LeagueSettings {
        data = typeof data === 'object' ? data : {};
        let result = new LeagueSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["totalPicks"] = this.totalPicks;
        data["keyPicks"] = this.keyPicks;
        data["keyPickBonus"] = this.keyPickBonus;
        data["weekStartingMoney"] = this.weekStartingMoney;
        data["minimumGamesToPick"] = this.minimumGamesToPick;
        data["allowParlays"] = this.allowParlays;
        data["allowWinningsForBetting"] = this.allowWinningsForBetting;
        data["lockPicksAfterTheyAreMade"] = this.lockPicksAfterTheyAreMade;
        data["lockSpreadsDuringWeek"] = this.lockSpreadsDuringWeek;
        return data;
    }
}

export interface ILeagueSettings {
    totalPicks?: number;
    keyPicks?: number;
    keyPickBonus?: number;
    weekStartingMoney?: number;
    minimumGamesToPick?: number;
    allowParlays?: boolean;
    allowWinningsForBetting?: boolean;
    lockPicksAfterTheyAreMade?: boolean;
    lockSpreadsDuringWeek?: boolean;

    [key: string]: any;
}

export class LoginRequest implements ILoginRequest {
    email!: string;
    password!: string;
    twoFactorCode?: string | undefined;
    twoFactorRecoveryCode?: string | undefined;

    [key: string]: any;

    constructor(data?: ILoginRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.email = _data["email"];
            this.password = _data["password"];
            this.twoFactorCode = _data["twoFactorCode"];
            this.twoFactorRecoveryCode = _data["twoFactorRecoveryCode"];
        }
    }

    static fromJS(data: any): LoginRequest {
        data = typeof data === 'object' ? data : {};
        let result = new LoginRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["email"] = this.email;
        data["password"] = this.password;
        data["twoFactorCode"] = this.twoFactorCode;
        data["twoFactorRecoveryCode"] = this.twoFactorRecoveryCode;
        return data;
    }
}

export interface ILoginRequest {
    email: string;
    password: string;
    twoFactorCode?: string | undefined;
    twoFactorRecoveryCode?: string | undefined;

    [key: string]: any;
}

export class Moneyline implements IMoneyline {
    timeOfMeasurement?: Date;
    homeTeamPrice?: number;
    awayTeamPrice?: number;

    [key: string]: any;

    constructor(data?: IMoneyline) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.timeOfMeasurement = _data["timeOfMeasurement"] ? new Date(_data["timeOfMeasurement"].toString()) : undefined as any;
            this.homeTeamPrice = _data["homeTeamPrice"];
            this.awayTeamPrice = _data["awayTeamPrice"];
        }
    }

    static fromJS(data: any): Moneyline {
        data = typeof data === 'object' ? data : {};
        let result = new Moneyline();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["timeOfMeasurement"] = this.timeOfMeasurement ? this.timeOfMeasurement.toISOString() : undefined as any;
        data["homeTeamPrice"] = this.homeTeamPrice;
        data["awayTeamPrice"] = this.awayTeamPrice;
        return data;
    }
}

export interface IMoneyline {
    timeOfMeasurement?: Date;
    homeTeamPrice?: number;
    awayTeamPrice?: number;

    [key: string]: any;
}

export class Moneyline2 implements IMoneyline2 {
    timeOfMeasurement?: Date;
    homeTeamPrice?: number;
    awayTeamPrice?: number;

    [key: string]: any;

    constructor(data?: IMoneyline2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.timeOfMeasurement = _data["timeOfMeasurement"] ? new Date(_data["timeOfMeasurement"].toString()) : undefined as any;
            this.homeTeamPrice = _data["homeTeamPrice"];
            this.awayTeamPrice = _data["awayTeamPrice"];
        }
    }

    static fromJS(data: any): Moneyline2 {
        data = typeof data === 'object' ? data : {};
        let result = new Moneyline2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["timeOfMeasurement"] = this.timeOfMeasurement ? this.timeOfMeasurement.toISOString() : undefined as any;
        data["homeTeamPrice"] = this.homeTeamPrice;
        data["awayTeamPrice"] = this.awayTeamPrice;
        return data;
    }
}

export interface IMoneyline2 {
    timeOfMeasurement?: Date;
    homeTeamPrice?: number;
    awayTeamPrice?: number;

    [key: string]: any;
}

export class RefreshRequest implements IRefreshRequest {
    refreshToken!: string;

    [key: string]: any;

    constructor(data?: IRefreshRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.refreshToken = _data["refreshToken"];
        }
    }

    static fromJS(data: any): RefreshRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RefreshRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["refreshToken"] = this.refreshToken;
        return data;
    }
}

export interface IRefreshRequest {
    refreshToken: string;

    [key: string]: any;
}

export class RegisterRequest implements IRegisterRequest {
    email!: string;
    password!: string;

    [key: string]: any;

    constructor(data?: IRegisterRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): RegisterRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["email"] = this.email;
        data["password"] = this.password;
        return data;
    }
}

export interface IRegisterRequest {
    email: string;
    password: string;

    [key: string]: any;
}

export class ResendConfirmationEmailRequest implements IResendConfirmationEmailRequest {
    email!: string;

    [key: string]: any;

    constructor(data?: IResendConfirmationEmailRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): ResendConfirmationEmailRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ResendConfirmationEmailRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["email"] = this.email;
        return data;
    }
}

export interface IResendConfirmationEmailRequest {
    email: string;

    [key: string]: any;
}

export class ResetPasswordRequest implements IResetPasswordRequest {
    email!: string;
    resetCode!: string;
    newPassword!: string;

    [key: string]: any;

    constructor(data?: IResetPasswordRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.email = _data["email"];
            this.resetCode = _data["resetCode"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ResetPasswordRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["email"] = this.email;
        data["resetCode"] = this.resetCode;
        data["newPassword"] = this.newPassword;
        return data;
    }
}

export interface IResetPasswordRequest {
    email: string;
    resetCode: string;
    newPassword: string;

    [key: string]: any;
}

export class SeasonDateInformation implements ISeasonDateInformation {
    startOfWeekOne?: Date;
    endOfSeason?: Date;
    weekStartTimes?: WeekInformation[];

    [key: string]: any;

    constructor(data?: ISeasonDateInformation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.startOfWeekOne = _data["startOfWeekOne"] ? new Date(_data["startOfWeekOne"].toString()) : undefined as any;
            this.endOfSeason = _data["endOfSeason"] ? new Date(_data["endOfSeason"].toString()) : undefined as any;
            if (Array.isArray(_data["weekStartTimes"])) {
                this.weekStartTimes = [] as any;
                for (let item of _data["weekStartTimes"])
                    this.weekStartTimes!.push(WeekInformation.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SeasonDateInformation {
        data = typeof data === 'object' ? data : {};
        let result = new SeasonDateInformation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["startOfWeekOne"] = this.startOfWeekOne ? this.startOfWeekOne.toISOString() : undefined as any;
        data["endOfSeason"] = this.endOfSeason ? this.endOfSeason.toISOString() : undefined as any;
        if (Array.isArray(this.weekStartTimes)) {
            data["weekStartTimes"] = [];
            for (let item of this.weekStartTimes)
                data["weekStartTimes"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface ISeasonDateInformation {
    startOfWeekOne?: Date;
    endOfSeason?: Date;
    weekStartTimes?: WeekInformation[];

    [key: string]: any;
}

export class SeasonDateInformation2 implements ISeasonDateInformation2 {
    startOfWeekOne?: Date;
    endOfSeason?: Date;
    weekStartTimes?: WeekInformation[];

    [key: string]: any;

    constructor(data?: ISeasonDateInformation2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.startOfWeekOne = _data["startOfWeekOne"] ? new Date(_data["startOfWeekOne"].toString()) : undefined as any;
            this.endOfSeason = _data["endOfSeason"] ? new Date(_data["endOfSeason"].toString()) : undefined as any;
            if (Array.isArray(_data["weekStartTimes"])) {
                this.weekStartTimes = [] as any;
                for (let item of _data["weekStartTimes"])
                    this.weekStartTimes!.push(WeekInformation.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SeasonDateInformation2 {
        data = typeof data === 'object' ? data : {};
        let result = new SeasonDateInformation2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["startOfWeekOne"] = this.startOfWeekOne ? this.startOfWeekOne.toISOString() : undefined as any;
        data["endOfSeason"] = this.endOfSeason ? this.endOfSeason.toISOString() : undefined as any;
        if (Array.isArray(this.weekStartTimes)) {
            data["weekStartTimes"] = [];
            for (let item of this.weekStartTimes)
                data["weekStartTimes"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface ISeasonDateInformation2 {
    startOfWeekOne?: Date;
    endOfSeason?: Date;
    weekStartTimes?: WeekInformation[];

    [key: string]: any;
}

export class Spread implements ISpread {
    timeOfMeasurement?: Date;
    awayPrice!: number;
    homePrice!: number;
    spreadAmount?: number;
    spreadAverage!: number;
    isUnknownSpread?: boolean;

    [key: string]: any;

    constructor(data?: ISpread) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.timeOfMeasurement = _data["timeOfMeasurement"] ? new Date(_data["timeOfMeasurement"].toString()) : undefined as any;
            this.awayPrice = _data["awayPrice"];
            this.homePrice = _data["homePrice"];
            this.spreadAmount = _data["spreadAmount"];
            this.spreadAverage = _data["spreadAverage"];
            this.isUnknownSpread = _data["isUnknownSpread"];
        }
    }

    static fromJS(data: any): Spread {
        data = typeof data === 'object' ? data : {};
        let result = new Spread();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["timeOfMeasurement"] = this.timeOfMeasurement ? this.timeOfMeasurement.toISOString() : undefined as any;
        data["awayPrice"] = this.awayPrice;
        data["homePrice"] = this.homePrice;
        data["spreadAmount"] = this.spreadAmount;
        data["spreadAverage"] = this.spreadAverage;
        data["isUnknownSpread"] = this.isUnknownSpread;
        return data;
    }
}

export interface ISpread {
    timeOfMeasurement?: Date;
    awayPrice: number;
    homePrice: number;
    spreadAmount?: number;
    spreadAverage: number;
    isUnknownSpread?: boolean;

    [key: string]: any;
}

export class Spread2 implements ISpread2 {
    timeOfMeasurement?: Date;
    awayPrice!: number;
    homePrice!: number;
    spreadAmount?: number;
    spreadAverage!: number;
    isUnknownSpread?: boolean;

    [key: string]: any;

    constructor(data?: ISpread2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.timeOfMeasurement = _data["timeOfMeasurement"] ? new Date(_data["timeOfMeasurement"].toString()) : undefined as any;
            this.awayPrice = _data["awayPrice"];
            this.homePrice = _data["homePrice"];
            this.spreadAmount = _data["spreadAmount"];
            this.spreadAverage = _data["spreadAverage"];
            this.isUnknownSpread = _data["isUnknownSpread"];
        }
    }

    static fromJS(data: any): Spread2 {
        data = typeof data === 'object' ? data : {};
        let result = new Spread2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["timeOfMeasurement"] = this.timeOfMeasurement ? this.timeOfMeasurement.toISOString() : undefined as any;
        data["awayPrice"] = this.awayPrice;
        data["homePrice"] = this.homePrice;
        data["spreadAmount"] = this.spreadAmount;
        data["spreadAverage"] = this.spreadAverage;
        data["isUnknownSpread"] = this.isUnknownSpread;
        return data;
    }
}

export interface ISpread2 {
    timeOfMeasurement?: Date;
    awayPrice: number;
    homePrice: number;
    spreadAmount?: number;
    spreadAverage: number;
    isUnknownSpread?: boolean;

    [key: string]: any;
}

export class SpreadGamePickDTO implements ISpreadGamePickDTO {
    gameID?: string;
    gameStartTime?: Date;
    sidePicked?: number;
    isKeyPicked?: boolean;
    spreadWhenPicked?: Spread2;
    timeOfPick?: Date;
    isLocked?: boolean;
    pickType?: number;
    isEdited?: boolean;

    [key: string]: any;

    constructor(data?: ISpreadGamePickDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.gameID = _data["gameID"];
            this.gameStartTime = _data["gameStartTime"] ? new Date(_data["gameStartTime"].toString()) : undefined as any;
            this.sidePicked = _data["sidePicked"];
            this.isKeyPicked = _data["isKeyPicked"];
            this.spreadWhenPicked = _data["spreadWhenPicked"] ? Spread2.fromJS(_data["spreadWhenPicked"]) : undefined as any;
            this.timeOfPick = _data["timeOfPick"] ? new Date(_data["timeOfPick"].toString()) : undefined as any;
            this.isLocked = _data["isLocked"];
            this.pickType = _data["pickType"];
            this.isEdited = _data["isEdited"];
        }
    }

    static fromJS(data: any): SpreadGamePickDTO {
        data = typeof data === 'object' ? data : {};
        let result = new SpreadGamePickDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["gameID"] = this.gameID;
        data["gameStartTime"] = this.gameStartTime ? this.gameStartTime.toISOString() : undefined as any;
        data["sidePicked"] = this.sidePicked;
        data["isKeyPicked"] = this.isKeyPicked;
        data["spreadWhenPicked"] = this.spreadWhenPicked ? this.spreadWhenPicked.toJSON() : undefined as any;
        data["timeOfPick"] = this.timeOfPick ? this.timeOfPick.toISOString() : undefined as any;
        data["isLocked"] = this.isLocked;
        data["pickType"] = this.pickType;
        data["isEdited"] = this.isEdited;
        return data;
    }
}

export interface ISpreadGamePickDTO {
    gameID?: string;
    gameStartTime?: Date;
    sidePicked?: number;
    isKeyPicked?: boolean;
    spreadWhenPicked?: Spread2;
    timeOfPick?: Date;
    isLocked?: boolean;
    pickType?: number;
    isEdited?: boolean;

    [key: string]: any;
}

export class SpreadWeekPickDTO implements ISpreadWeekPickDTO {
    id?: string | undefined;
    leagueId?: string | undefined;
    userId?: string | undefined;
    sport?: number;
    weekNumber?: number;
    year?: string | undefined;
    gamePicks?: SpreadGamePickDTO[] | undefined;
    isFinal?: boolean;
    processed?: boolean;

    [key: string]: any;

    constructor(data?: ISpreadWeekPickDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.leagueId = _data["leagueId"];
            this.userId = _data["userId"];
            this.sport = _data["sport"];
            this.weekNumber = _data["weekNumber"];
            this.year = _data["year"];
            if (Array.isArray(_data["gamePicks"])) {
                this.gamePicks = [] as any;
                for (let item of _data["gamePicks"])
                    this.gamePicks!.push(SpreadGamePickDTO.fromJS(item));
            }
            this.isFinal = _data["isFinal"];
            this.processed = _data["processed"];
        }
    }

    static fromJS(data: any): SpreadWeekPickDTO {
        data = typeof data === 'object' ? data : {};
        let result = new SpreadWeekPickDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["leagueId"] = this.leagueId;
        data["userId"] = this.userId;
        data["sport"] = this.sport;
        data["weekNumber"] = this.weekNumber;
        data["year"] = this.year;
        if (Array.isArray(this.gamePicks)) {
            data["gamePicks"] = [];
            for (let item of this.gamePicks)
                data["gamePicks"].push(item ? item.toJSON() : undefined as any);
        }
        data["isFinal"] = this.isFinal;
        data["processed"] = this.processed;
        return data;
    }
}

export interface ISpreadWeekPickDTO {
    id?: string | undefined;
    leagueId?: string | undefined;
    userId?: string | undefined;
    sport?: number;
    weekNumber?: number;
    year?: string | undefined;
    gamePicks?: SpreadGamePickDTO[] | undefined;
    isFinal?: boolean;
    processed?: boolean;

    [key: string]: any;
}

export class TeamDTO implements ITeamDTO {
    id?: string | undefined;
    sport?: number | undefined;
    partitionKey?: string | undefined;
    city?: string | undefined;
    name?: string | undefined;
    abbreviation?: string | undefined;
    conference?: string | undefined;
    division?: string | undefined;
    emoji?: string;

    [key: string]: any;

    constructor(data?: ITeamDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.sport = _data["sport"];
            this.partitionKey = _data["partitionKey"];
            this.city = _data["city"];
            this.name = _data["name"];
            this.abbreviation = _data["abbreviation"];
            this.conference = _data["conference"];
            this.division = _data["division"];
            this.emoji = _data["emoji"];
        }
    }

    static fromJS(data: any): TeamDTO {
        data = typeof data === 'object' ? data : {};
        let result = new TeamDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["sport"] = this.sport;
        data["partitionKey"] = this.partitionKey;
        data["city"] = this.city;
        data["name"] = this.name;
        data["abbreviation"] = this.abbreviation;
        data["conference"] = this.conference;
        data["division"] = this.division;
        data["emoji"] = this.emoji;
        return data;
    }
}

export interface ITeamDTO {
    id?: string | undefined;
    sport?: number | undefined;
    partitionKey?: string | undefined;
    city?: string | undefined;
    name?: string | undefined;
    abbreviation?: string | undefined;
    conference?: string | undefined;
    division?: string | undefined;
    emoji?: string;

    [key: string]: any;
}

export class TimeZoneInfo implements ITimeZoneInfo {
    id?: string | undefined;
    hasIanaId?: boolean;
    displayName?: string | undefined;
    standardName?: string | undefined;
    daylightName?: string | undefined;
    baseUtcOffset?: string;
    supportsDaylightSavingTime?: boolean;

    [key: string]: any;

    constructor(data?: ITimeZoneInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.hasIanaId = _data["hasIanaId"];
            this.displayName = _data["displayName"];
            this.standardName = _data["standardName"];
            this.daylightName = _data["daylightName"];
            this.baseUtcOffset = _data["baseUtcOffset"];
            this.supportsDaylightSavingTime = _data["supportsDaylightSavingTime"];
        }
    }

    static fromJS(data: any): TimeZoneInfo {
        data = typeof data === 'object' ? data : {};
        let result = new TimeZoneInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["hasIanaId"] = this.hasIanaId;
        data["displayName"] = this.displayName;
        data["standardName"] = this.standardName;
        data["daylightName"] = this.daylightName;
        data["baseUtcOffset"] = this.baseUtcOffset;
        data["supportsDaylightSavingTime"] = this.supportsDaylightSavingTime;
        return data;
    }
}

export interface ITimeZoneInfo {
    id?: string | undefined;
    hasIanaId?: boolean;
    displayName?: string | undefined;
    standardName?: string | undefined;
    daylightName?: string | undefined;
    baseUtcOffset?: string;
    supportsDaylightSavingTime?: boolean;

    [key: string]: any;
}

export class TotalPointsSpread implements ITotalPointsSpread {
    timeOfMeasurement?: Date;
    totalPoints!: number;
    underPointsPrice?: number;
    overPointsPrice?: number;

    [key: string]: any;

    constructor(data?: ITotalPointsSpread) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.timeOfMeasurement = _data["timeOfMeasurement"] ? new Date(_data["timeOfMeasurement"].toString()) : undefined as any;
            this.totalPoints = _data["totalPoints"];
            this.underPointsPrice = _data["underPointsPrice"];
            this.overPointsPrice = _data["overPointsPrice"];
        }
    }

    static fromJS(data: any): TotalPointsSpread {
        data = typeof data === 'object' ? data : {};
        let result = new TotalPointsSpread();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["timeOfMeasurement"] = this.timeOfMeasurement ? this.timeOfMeasurement.toISOString() : undefined as any;
        data["totalPoints"] = this.totalPoints;
        data["underPointsPrice"] = this.underPointsPrice;
        data["overPointsPrice"] = this.overPointsPrice;
        return data;
    }
}

export interface ITotalPointsSpread {
    timeOfMeasurement?: Date;
    totalPoints: number;
    underPointsPrice?: number;
    overPointsPrice?: number;

    [key: string]: any;
}

export class TotalPointsSpread2 implements ITotalPointsSpread2 {
    timeOfMeasurement?: Date;
    totalPoints!: number;
    underPointsPrice?: number;
    overPointsPrice?: number;

    [key: string]: any;

    constructor(data?: ITotalPointsSpread2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.timeOfMeasurement = _data["timeOfMeasurement"] ? new Date(_data["timeOfMeasurement"].toString()) : undefined as any;
            this.totalPoints = _data["totalPoints"];
            this.underPointsPrice = _data["underPointsPrice"];
            this.overPointsPrice = _data["overPointsPrice"];
        }
    }

    static fromJS(data: any): TotalPointsSpread2 {
        data = typeof data === 'object' ? data : {};
        let result = new TotalPointsSpread2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["timeOfMeasurement"] = this.timeOfMeasurement ? this.timeOfMeasurement.toISOString() : undefined as any;
        data["totalPoints"] = this.totalPoints;
        data["underPointsPrice"] = this.underPointsPrice;
        data["overPointsPrice"] = this.overPointsPrice;
        return data;
    }
}

export interface ITotalPointsSpread2 {
    timeOfMeasurement?: Date;
    totalPoints: number;
    underPointsPrice?: number;
    overPointsPrice?: number;

    [key: string]: any;
}

export class TwoFactorRequest implements ITwoFactorRequest {
    enable?: boolean | undefined;
    twoFactorCode?: string | undefined;
    resetSharedKey?: boolean;
    resetRecoveryCodes?: boolean;
    forgetMachine?: boolean;

    [key: string]: any;

    constructor(data?: ITwoFactorRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.enable = _data["enable"];
            this.twoFactorCode = _data["twoFactorCode"];
            this.resetSharedKey = _data["resetSharedKey"];
            this.resetRecoveryCodes = _data["resetRecoveryCodes"];
            this.forgetMachine = _data["forgetMachine"];
        }
    }

    static fromJS(data: any): TwoFactorRequest {
        data = typeof data === 'object' ? data : {};
        let result = new TwoFactorRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["enable"] = this.enable;
        data["twoFactorCode"] = this.twoFactorCode;
        data["resetSharedKey"] = this.resetSharedKey;
        data["resetRecoveryCodes"] = this.resetRecoveryCodes;
        data["forgetMachine"] = this.forgetMachine;
        return data;
    }
}

export interface ITwoFactorRequest {
    enable?: boolean | undefined;
    twoFactorCode?: string | undefined;
    resetSharedKey?: boolean;
    resetRecoveryCodes?: boolean;
    forgetMachine?: boolean;

    [key: string]: any;
}

export class TwoFactorResponse implements ITwoFactorResponse {
    sharedKey!: string;
    recoveryCodesLeft!: number;
    recoveryCodes?: string[] | undefined;
    isTwoFactorEnabled!: boolean;
    isMachineRemembered!: boolean;

    [key: string]: any;

    constructor(data?: ITwoFactorResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.sharedKey = _data["sharedKey"];
            this.recoveryCodesLeft = _data["recoveryCodesLeft"];
            if (Array.isArray(_data["recoveryCodes"])) {
                this.recoveryCodes = [] as any;
                for (let item of _data["recoveryCodes"])
                    this.recoveryCodes!.push(item);
            }
            this.isTwoFactorEnabled = _data["isTwoFactorEnabled"];
            this.isMachineRemembered = _data["isMachineRemembered"];
        }
    }

    static fromJS(data: any): TwoFactorResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TwoFactorResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["sharedKey"] = this.sharedKey;
        data["recoveryCodesLeft"] = this.recoveryCodesLeft;
        if (Array.isArray(this.recoveryCodes)) {
            data["recoveryCodes"] = [];
            for (let item of this.recoveryCodes)
                data["recoveryCodes"].push(item);
        }
        data["isTwoFactorEnabled"] = this.isTwoFactorEnabled;
        data["isMachineRemembered"] = this.isMachineRemembered;
        return data;
    }
}

export interface ITwoFactorResponse {
    sharedKey: string;
    recoveryCodesLeft: number;
    recoveryCodes?: string[] | undefined;
    isTwoFactorEnabled: boolean;
    isMachineRemembered: boolean;

    [key: string]: any;
}

export class UpdateLeagueSettingsRequest implements IUpdateLeagueSettingsRequest {
    leagueId?: string;
    settings?: LeagueSettings;
    leagueName?: string;
    isPublic?: boolean;
    isArchived?: boolean;
    startingWeekNumber?: number;
    endingWeekNumber?: number;

    [key: string]: any;

    constructor(data?: IUpdateLeagueSettingsRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.leagueId = _data["leagueId"];
            this.settings = _data["settings"] ? LeagueSettings.fromJS(_data["settings"]) : undefined as any;
            this.leagueName = _data["leagueName"];
            this.isPublic = _data["isPublic"];
            this.isArchived = _data["isArchived"];
            this.startingWeekNumber = _data["startingWeekNumber"];
            this.endingWeekNumber = _data["endingWeekNumber"];
        }
    }

    static fromJS(data: any): UpdateLeagueSettingsRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLeagueSettingsRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["leagueId"] = this.leagueId;
        data["settings"] = this.settings ? this.settings.toJSON() : undefined as any;
        data["leagueName"] = this.leagueName;
        data["isPublic"] = this.isPublic;
        data["isArchived"] = this.isArchived;
        data["startingWeekNumber"] = this.startingWeekNumber;
        data["endingWeekNumber"] = this.endingWeekNumber;
        return data;
    }
}

export interface IUpdateLeagueSettingsRequest {
    leagueId?: string;
    settings?: LeagueSettings;
    leagueName?: string;
    isPublic?: boolean;
    isArchived?: boolean;
    startingWeekNumber?: number;
    endingWeekNumber?: number;

    [key: string]: any;
}

export class UserInfo implements IUserInfo {
    id?: string;
    userName?: string;
    email?: string;

    [key: string]: any;

    constructor(data?: IUserInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): UserInfo {
        data = typeof data === 'object' ? data : {};
        let result = new UserInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["email"] = this.email;
        return data;
    }
}

export interface IUserInfo {
    id?: string;
    userName?: string;
    email?: string;

    [key: string]: any;
}

export class UserSeason implements IUserSeason {
    userId!: string;
    year!: string;
    totalPoints?: number;
    availableMoney?: number;
    weekStartingMoney?: number;
    seasonTrophies?: number[];
    showAllGamesOnStandings?: boolean;
    showIconsForPicksOnStandings?: boolean;
    processedWeekResults?: string[];

    [key: string]: any;

    constructor(data?: IUserSeason) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.userId = _data["userId"];
            this.year = _data["year"];
            this.totalPoints = _data["totalPoints"];
            this.availableMoney = _data["availableMoney"];
            this.weekStartingMoney = _data["weekStartingMoney"];
            if (Array.isArray(_data["seasonTrophies"])) {
                this.seasonTrophies = [] as any;
                for (let item of _data["seasonTrophies"])
                    this.seasonTrophies!.push(item);
            }
            this.showAllGamesOnStandings = _data["showAllGamesOnStandings"];
            this.showIconsForPicksOnStandings = _data["showIconsForPicksOnStandings"];
            if (Array.isArray(_data["processedWeekResults"])) {
                this.processedWeekResults = [] as any;
                for (let item of _data["processedWeekResults"])
                    this.processedWeekResults!.push(item);
            }
        }
    }

    static fromJS(data: any): UserSeason {
        data = typeof data === 'object' ? data : {};
        let result = new UserSeason();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["userId"] = this.userId;
        data["year"] = this.year;
        data["totalPoints"] = this.totalPoints;
        data["availableMoney"] = this.availableMoney;
        data["weekStartingMoney"] = this.weekStartingMoney;
        if (Array.isArray(this.seasonTrophies)) {
            data["seasonTrophies"] = [];
            for (let item of this.seasonTrophies)
                data["seasonTrophies"].push(item);
        }
        data["showAllGamesOnStandings"] = this.showAllGamesOnStandings;
        data["showIconsForPicksOnStandings"] = this.showIconsForPicksOnStandings;
        if (Array.isArray(this.processedWeekResults)) {
            data["processedWeekResults"] = [];
            for (let item of this.processedWeekResults)
                data["processedWeekResults"].push(item);
        }
        return data;
    }
}

export interface IUserSeason {
    userId: string;
    year: string;
    totalPoints?: number;
    availableMoney?: number;
    weekStartingMoney?: number;
    seasonTrophies?: number[];
    showAllGamesOnStandings?: boolean;
    showIconsForPicksOnStandings?: boolean;
    processedWeekResults?: string[];

    [key: string]: any;
}

export class UserSeasonDTO implements IUserSeasonDTO {
    userId?: string;
    year?: string;
    totalPoints?: number;
    availableMoney?: number;
    weekStartingMoney?: number;
    seasonTrophies?: number[];
    showAllGamesOnStandings?: boolean;
    showIconsForPicksOnStandings?: boolean;
    processedWeekResults?: string[];

    [key: string]: any;

    constructor(data?: IUserSeasonDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.userId = _data["userId"];
            this.year = _data["year"];
            this.totalPoints = _data["totalPoints"];
            this.availableMoney = _data["availableMoney"];
            this.weekStartingMoney = _data["weekStartingMoney"];
            if (Array.isArray(_data["seasonTrophies"])) {
                this.seasonTrophies = [] as any;
                for (let item of _data["seasonTrophies"])
                    this.seasonTrophies!.push(item);
            }
            this.showAllGamesOnStandings = _data["showAllGamesOnStandings"];
            this.showIconsForPicksOnStandings = _data["showIconsForPicksOnStandings"];
            if (Array.isArray(_data["processedWeekResults"])) {
                this.processedWeekResults = [] as any;
                for (let item of _data["processedWeekResults"])
                    this.processedWeekResults!.push(item);
            }
        }
    }

    static fromJS(data: any): UserSeasonDTO {
        data = typeof data === 'object' ? data : {};
        let result = new UserSeasonDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["userId"] = this.userId;
        data["year"] = this.year;
        data["totalPoints"] = this.totalPoints;
        data["availableMoney"] = this.availableMoney;
        data["weekStartingMoney"] = this.weekStartingMoney;
        if (Array.isArray(this.seasonTrophies)) {
            data["seasonTrophies"] = [];
            for (let item of this.seasonTrophies)
                data["seasonTrophies"].push(item);
        }
        data["showAllGamesOnStandings"] = this.showAllGamesOnStandings;
        data["showIconsForPicksOnStandings"] = this.showIconsForPicksOnStandings;
        if (Array.isArray(this.processedWeekResults)) {
            data["processedWeekResults"] = [];
            for (let item of this.processedWeekResults)
                data["processedWeekResults"].push(item);
        }
        return data;
    }
}

export interface IUserSeasonDTO {
    userId?: string;
    year?: string;
    totalPoints?: number;
    availableMoney?: number;
    weekStartingMoney?: number;
    seasonTrophies?: number[];
    showAllGamesOnStandings?: boolean;
    showIconsForPicksOnStandings?: boolean;
    processedWeekResults?: string[];

    [key: string]: any;
}

export class UserSettings implements IUserSettings {
    userId!: string;
    partitionKey?: string;
    discordUserId!: string;
    timeZoneInfoId!: string;
    timeZoneInfo?: TimeZoneInfo | undefined;

    [key: string]: any;

    constructor(data?: IUserSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.userId = _data["userId"];
            this.partitionKey = _data["partitionKey"];
            this.discordUserId = _data["discordUserId"];
            this.timeZoneInfoId = _data["timeZoneInfoId"];
            this.timeZoneInfo = _data["timeZoneInfo"] ? TimeZoneInfo.fromJS(_data["timeZoneInfo"]) : undefined as any;
        }
    }

    static fromJS(data: any): UserSettings {
        data = typeof data === 'object' ? data : {};
        let result = new UserSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["userId"] = this.userId;
        data["partitionKey"] = this.partitionKey;
        data["discordUserId"] = this.discordUserId;
        data["timeZoneInfoId"] = this.timeZoneInfoId;
        data["timeZoneInfo"] = this.timeZoneInfo ? this.timeZoneInfo.toJSON() : undefined as any;
        return data;
    }
}

export interface IUserSettings {
    userId: string;
    partitionKey?: string;
    discordUserId: string;
    timeZoneInfoId: string;
    timeZoneInfo?: TimeZoneInfo | undefined;

    [key: string]: any;
}

export class WeatherForecast implements IWeatherForecast {
    date?: Date;
    temperatureC?: number;
    temperatureF?: number;
    summary?: string | undefined;

    [key: string]: any;

    constructor(data?: IWeatherForecast) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.date = _data["date"] ? new Date(_data["date"].toString()) : undefined as any;
            this.temperatureC = _data["temperatureC"];
            this.temperatureF = _data["temperatureF"];
            this.summary = _data["summary"];
        }
    }

    static fromJS(data: any): WeatherForecast {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherForecast();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["date"] = this.date ? formatDate(this.date) : undefined as any;
        data["temperatureC"] = this.temperatureC;
        data["temperatureF"] = this.temperatureF;
        data["summary"] = this.summary;
        return data;
    }
}

export interface IWeatherForecast {
    date?: Date;
    temperatureC?: number;
    temperatureF?: number;
    summary?: string | undefined;

    [key: string]: any;
}

export class WeekInformation implements IWeekInformation {
    weekDescription?: string;
    weekStartTime?: Date;
    weekEndTime?: Date;
    daysInWeek?: number;
    allowAllPicks?: boolean;
    weekNumber?: number;

    [key: string]: any;

    constructor(data?: IWeekInformation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.weekDescription = _data["weekDescription"];
            this.weekStartTime = _data["weekStartTime"] ? new Date(_data["weekStartTime"].toString()) : undefined as any;
            this.weekEndTime = _data["weekEndTime"] ? new Date(_data["weekEndTime"].toString()) : undefined as any;
            this.daysInWeek = _data["daysInWeek"];
            this.allowAllPicks = _data["allowAllPicks"];
            this.weekNumber = _data["weekNumber"];
        }
    }

    static fromJS(data: any): WeekInformation {
        data = typeof data === 'object' ? data : {};
        let result = new WeekInformation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["weekDescription"] = this.weekDescription;
        data["weekStartTime"] = this.weekStartTime ? this.weekStartTime.toISOString() : undefined as any;
        data["weekEndTime"] = this.weekEndTime ? this.weekEndTime.toISOString() : undefined as any;
        data["daysInWeek"] = this.daysInWeek;
        data["allowAllPicks"] = this.allowAllPicks;
        data["weekNumber"] = this.weekNumber;
        return data;
    }
}

export interface IWeekInformation {
    weekDescription?: string;
    weekStartTime?: Date;
    weekEndTime?: Date;
    daysInWeek?: number;
    allowAllPicks?: boolean;
    weekNumber?: number;

    [key: string]: any;
}

function formatDate(d: Date) {
    return d.getFullYear() + '-' + 
        (d.getMonth() < 9 ? ('0' + (d.getMonth()+1)) : (d.getMonth()+1)) + '-' +
        (d.getDate() < 10 ? ('0' + d.getDate()) : d.getDate());
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}